<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Belajar Laravel</title>

    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="container">
        <aside id="aside">

        </aside>
        <main>
            <header>
                
            </header>

            <div class="content">
<pre>
    ğŸ“˜ 4ï¸âƒ£ Apa Itu Eloquent?

    Eloquent adalah:

    ORM (Object Relational Mapping) bawaan Laravel untuk berinteraksi dengan database menggunakan object PHP.

    Artinyaâ€¦

    Kita tidak lagi berpikir dalam bentuk:

    SELECT * FROM products;


    Tapi dalam bentuk:

    Product::all();


    Lebih clean. Lebih readable. Lebih modern.

    
    
    
    
    
    ğŸ§  Apa Itu ORM?

    ORM = Object Relational Mapping

    Konsepnya:

    Database	PHP
    Tabel	Class (Model)
    Baris	Object
    Kolom	Property
    Relasi	Method

    Jadi Eloquent mengubah:
    Database â†’ Object Oriented

    
    
    
    
    
    ğŸ”¥ Kenapa Laravel Pakai Eloquent?

    Karena Eloquent:

    âœ… Mudah dibaca
    âœ… Aman (hindari SQL Injection)
    âœ… Support relasi otomatis
    âœ… Support query chaining
    âœ… Terintegrasi dengan Model
    âœ… Support event, casting, accessor, mutator

    Dan ini bikin Laravel terasa â€œcleanâ€.

    
    
    
    
    
    ğŸ§± Cara Kerja Eloquent Secara Internal

    Contoh:

    Product::where('price', '>', 100000)->get();


    Yang terjadi di belakang layar:

    Eloquent membaca model Product

    Menentukan tabel: products

    Membuat SQL query otomatis

    Kirim query ke MySQL

    Ambil hasil

    Ubah hasil jadi collection object

    Kita tidak pernah melihat SQL-nya.

    
    
    
    
    
    ğŸ§  Eloquent Itu Sebenarnya Ada Berapa Banyak?

    Pertanyaan bagus ğŸ”¥

    Jawabannya:

    Eloquent bukan â€œjumlah fitur tetapâ€.

    Tapi terdiri dari beberapa bagian besar:

    
    
    
    
    
    1ï¸âƒ£ Query Builder Method

    Ratusan method tersedia, seperti:

    all()

    find()

    where()

    first()

    get()

    create()

    update()

    delete()

    orderBy()

    paginate()

    count()

    sum()

    avg()

    dll

    Total method aktif: 100+ method bawaan

    Dan bisa ditambah sendiri (custom scope).

    
    
    
    
    
    2ï¸âƒ£ Relationship Type

    Eloquent punya beberapa jenis relasi utama:

    One to One

    One to Many

    Many to Many

    Has Many Through

    Polymorphic (MorphOne, MorphMany, dll)

    Kalau dihitung lengkap, ada sekitar 8â€“10 tipe relasi berbeda.

   
   
   
   
   
    3ï¸âƒ£ Feature Tambahan Eloquent

    Selain query & relasi, Eloquent juga punya:

    Accessor & Mutator

    Casting

    Soft Delete

    Model Event

    Scope (Local & Global)

    Attribute

    Mass Assignment

    Lazy / Eager Loading

    Chunking

    Observer

    Jadi total konsep pentingnya bisa 20+ fitur besar.

    
    
    
    
    
    ğŸ§  Mental Model Eloquent

    Bayangkan seperti ini:

    Database itu dunia nyata.
    Model itu manusia.
    Eloquent itu sistem komunikasi antara manusia dan dunia nyata.

    Kita berbicara dengan Model,
    Model berbicara dengan Database.

    
    
    
    
    
    ğŸ¯ Perbandingan SQL vs Eloquent

    SQL:

    SELECT * FROM products WHERE price > 100000;


    Eloquent:

    Product::where('price', '>', 100000)->get();


    Lebih natural untuk programmer PHP.

    
    
    
    
    
    âš¡ Kapan Tidak Pakai Eloquent?

    Kadang kita pakai:

    Query Builder langsung

    Raw SQL

    Biasanya kalau:

    Query sangat kompleks

    Butuh performa super tinggi

    Query khusus database

    Tapi 90% aplikasi Laravel pakai Eloquent.

    
    
    
    
    
    ğŸ Kesimpulan Besar

    Eloquent adalah:

    Mesin utama Laravel untuk mengelola database secara object-oriented.

    Total fitur:

    100+ query method

    8â€“10 tipe relasi

    20+ fitur tambahan

    Tapi tenangâ€¦

    Kita tidak perlu hafal semua.

    
    
    
    
    
    Cukup kuasai:

    Basic Query

    Relasi

    Eager loading

    Mass assignment

    Itu sudah cukup untuk 80% project ğŸ”¥
</pre>




<br> <br>

<hr>

<br> <br>



<pre>
    ğŸ‘‰ find(), where(), first()

    Ini 3 method yang akan kamu pakai hampir setiap hari.

    
    
    
    
    
    ğŸ§  1ï¸âƒ£ find()
    ğŸ“Œ Fungsi:

    Mengambil data berdasarkan primary key (biasanya id).

    Contoh:
    Product::find(1);


    Artinya:

    Ambil data dari tabel products dengan id = 1

    SQL-nya kira-kira:

    SELECT * FROM products WHERE id = 1 LIMIT 1;

    âš  Kalau Data Tidak Ada?

    find() akan mengembalikan:

    null


    Jadi harus hati-hati:

    $product = Product::find(1);

    if ($product) {
        echo $product->name;
    }

    ğŸ”¥ Versi Lebih Aman: findOrFail()
    Product::findOrFail(1);


    Kalau tidak ada data:
    â¡ otomatis 404 error

    Ini sering dipakai di controller.

    
    
    
    
    
    ğŸ§  2ï¸âƒ£ where()
    ğŸ“Œ Fungsi:

    Mencari data dengan kondisi tertentu.

    Contoh Dasar:
    Product::where('price', '>', 100000)->get();


    Artinya:

    Ambil semua produk dengan harga > 100000

    
    
    
    
    
    âš  Penting!

    where() BELUM mengeksekusi query.

    Ia hanya membangun query.

    Query baru jalan saat kita pakai:

    get()

    first()

    count()

    dll

    Contoh Salah (Pemula sering salah):
    Product::where('price', '>', 100000);


    Ini tidak ambil data.

    Harus:

    Product::where('price', '>', 100000)->get();

    
    
    
    
    
    ğŸ§  Multiple Where
    Product::where('price', '>', 100000)
        ->where('is_active', 1)
        ->get();

    ğŸ”¥ Versi Singkat

    Kalau operator "=" bisa:

    Product::where('name', 'Laptop')->get();

    
    
    
    
    
    ğŸ§  3ï¸âƒ£ first()
    ğŸ“Œ Fungsi:

    Mengambil 1 data pertama dari hasil query.

    Contoh:
    Product::where('price', '>', 100000)->first();


    Artinya:

    Ambil 1 produk pertama dengan harga > 100000

    SQL kira-kira:

    SELECT * FROM products WHERE price > 100000 LIMIT 1;

    
    
    
    
    
    âš  Perbedaan get() vs first()
    get()

    Mengembalikan:

    Collection

    first()

    Mengembalikan:

    Object Model atau null

    Contoh Perbedaan:
    $products = Product::where('price', '>', 100000)->get();


    Loop:

    foreach ($products as $product)

    $product = Product::where('price', '>', 100000)->first();


    Langsung akses:

    $product->name;

    
    
    
    
    
    ğŸ”¥ Versi Aman: firstOrFail()
    Product::where('price', '>', 100000)->firstOrFail();


    Kalau tidak ada data:
    â¡ 404 otomatis

    
    
    
    
    
    ğŸ§  Ringkasan Perbedaan
    Method	Ambil Apa	Return
    find()	by ID	1 object / null
    where()	kondisi	perlu get()/first()
    first()	1 data pertama	object / null
    get()	semua data	collection
    
    
    
    
    
    ğŸ¯ Contoh Real di Controller
    public function show($id)
    {
        $product = Product::findOrFail($id);
        return view('products.show', compact('product'));
    }


    Atau:

    public function expensive()
    {
        $products = Product::where('price', '>', 1000000)->get();
        return view('products.expensive', compact('products'));
    }

    
    
    
    
    
    ğŸ§  Kapan Pakai Apa?

    âœ” Pakai find() kalau cari by ID
    âœ” Pakai where() kalau ada kondisi
    âœ” Pakai first() kalau cuma butuh 1 data
    âœ” Pakai get() kalau butuh banyak data

    
    
    
    
    
    ğŸ Kesimpulan

    3 method ini adalah fondasi Eloquent.

    Kalau kamu sudah paham ini,
    kamu sudah menguasai 60% query Laravel ğŸ”¥







    ADDITIONAL 1:
    QUESTION: apakah where itu berpotensi untuk tidak menggunakan INDEX database?



    Pertanyaan yang sangat cerdas! Jawabannya adalah Ya, sangat berpotensi.

    Meskipun kamu sudah memasang INDEX pada sebuah kolom, database (seperti MySQL) bisa saja memutuskan untuk mengabaikannya dan melakukan Full Table Scan (membaca seluruh isi tabel dari awal sampai akhir). Ini adalah salah satu penyebab utama aplikasi menjadi lambat saat data sudah mencapai ribuan atau jutaan baris.

    Berikut adalah beberapa kondisi yang menyebabkan `WHERE` mengabaikan INDEX:

    ---

    ### 1. Menggunakan Fungsi atau Manipulasi pada Kolom

    Jika kamu membungkus kolom di dalam fungsi, database tidak bisa menggunakan index karena nilai di dalam index tersebut sudah "berubah" di mata database.

    * Salah (Index diabaikan):
    ```sql
    SELECT * FROM products WHERE YEAR(created_at) = 2024;

    ```


    * Benar (Index digunakan):
    ```sql
    SELECT * FROM products WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31';

    ```



    ---

    ### 2. Menggunakan Wildcard (`%`) di Awal Kata

    Index pada database bekerja seperti indeks di buku telepon. Kamu bisa mencari "Budi%" dengan cepat karena urutannya jelas. Tapi kalau kamu mencari "%Budi", database harus mengecek setiap baris.

    * Index digunakan: `WHERE name LIKE 'Budi%'`
    * Index DIABAIKAN: `WHERE name LIKE '%Budi'`

    ---

    ### 3. Tipe Data Tidak Cocok (Implicit Conversion)

    Ini sering terjadi tanpa disadari. Jika kolom `merchant_id` bertipe String (Varchar), tapi kamu mencarinya menggunakan angka Integer, MySQL akan melakukan konversi tipe data pada setiap baris, yang mengakibatkan index tidak terpakai.

    * Potensi Lambat: `WHERE merchant_id = 123` (jika kolomnya string)
    * Cepat: `WHERE merchant_id = '123'`

    ---

    ### 4. Penggunaan Operator NOT atau Tidak Sama Dengan

    Operator negatif seperti `!=`, `<>`, atau `NOT IN` sering kali membuat database menyerah menggunakan index dan memilih melakukan *Full Table Scan* karena mencari "apa yang tidak ada" jauh lebih sulit daripada mencari "apa yang ada".

    ---

    ### 5. Kolom yang Kurang Selektif (Low Cardinality)

    Database punya "kecerdasan" bernama *Query Optimizer*. Jika kamu melakukan index pada kolom yang isinya hanya dua kemungkinan (misal: kolom `status` yang isinya hanya `aktif` dan `tidak_aktif`), database mungkin merasa:

    > *"Daripada repot-repot buka buku index tapi isinya hampir separuh tabel, mending saya baca langsung saja seluruh tabelnya."*

    ---

    ### 6. Melewatkan Urutan pada Composite Index

    Jika kamu membuat index gabungan (Composite Index) pada kolom `(merchant_id, category_id)`, kamu wajib menyertakan `merchant_id` di dalam `WHERE` agar index tersebut bekerja.

    * `WHERE merchant_id = 1 AND category_id = 2` (Index digunakan âœ…)
    * `WHERE category_id = 2` (Index diabaikan âŒ)

    ---

    ### Cara Cek Apakah Index Kamu Dipakai atau Tidak

    Kamu bisa menggunakan perintah EXPLAIN di tab SQL phpMyAdmin atau di terminal:

    ```sql
    EXPLAIN SELECT * FROM products WHERE price > 100000;

    ```

    Lihat kolom `type` dan `key`:

    * Jika `type` berisi `ALL`, berarti index tidak dipakai (Full Table Scan).
    * Jika `key` berisi nama index kamu, berarti index aman digunakan.

    Saran Saya:
    Saat kamu menulis query `WHERE`, bayangkan kamu sedang mencari nama di buku telepon. Jika caramu mencari memaksa kamu membuka setiap lembar buku, berarti query-mu tidak efektif.

    Apakah kamu sedang mengalami query yang terasa lambat saat ini?







    ADDITIONAL 2:
    QUESTION: apakah kode seperti berikut yang diambil adalah irisan dari kedua where?

    Product::where('price', '>', 100000)
    
            ->where('is_active', 1)
    
            ->get();


            

    Betul sekali! Dalam Laravel Eloquent, ketika kamu menyambungkan beberapa method `where()` secara berurutan (disebut *Method Chaining*), secara default Laravel akan menggabungkannya menggunakan operator logika AND.

    Dalam konsep himpunan, ini memang disebut sebagai Irisan (Intersection).

    ### 1. Bagaimana Database Membacanya?

    Kode Eloquent kamu akan diterjemahkan menjadi perintah SQL seperti ini:

    ```sql
    SELECT * FROM products 
    WHERE price > 100000 
    AND is_active = 1;

    ```

    Data yang ditarik hanya data yang memenuhi kedua syarat tersebut sekaligus. Jika ada produk yang harganya mahal tapi tidak aktif, atau produk aktif tapi harganya murah, mereka tidak akan ikut terbawa.

    ---

    ### 2. Visualisasi Irisan

    Bayangkan kamu memiliki dua lingkaran kriteria:

    * Lingkaran A: Semua produk dengan harga > 100.000.
    * Lingkaran B: Semua produk yang statusnya aktif (`is_active = 1`).

    Hasil dari query kamu adalah area di tengah-tengah di mana kedua lingkaran tersebut bertumpang tindih.

    ---

    ### 3. Bagaimana jika ingin "Gabungan" (Bukan Irisan)?

    Jika maksudmu adalah ingin mengambil produk yang harganya mahal ATAU produk yang aktif (salah satu syarat terpenuhi sudah cukup), maka kamu harus menggunakan `orWhere()`.

    ```php
    // Ini adalah GABUNGAN (Union)
    Product::where('price', '>', 100000)
            ->orWhere('is_active', 1)
            ->get();

    ```

    Dalam SQL, ini menjadi: `WHERE price > 100000 OR is_active = 1`.

    ---

    ### 4. Tips Performa: Masalah Index Lagi

    Menyambung pertanyaanmu sebelumnya tentang INDEX, jika kamu sering menjalankan query "irisan" seperti ini:

    * Jika kamu hanya punya index di `price`, database akan mencari harga dulu, baru memfilter `is_active` secara manual.
    * Jika datanya sangat besar (jutaan), akan jauh lebih cepat jika kamu membuat Composite Index (Index Gabungan) untuk kedua kolom tersebut sekaligus.

    Di Migration:

    ```php
    $table->index(['price', 'is_active']);

    ```

    ---

    ### ğŸ’¡ Hal yang Perlu Diwaspadai: Prioritas Query

    Hati-hati jika kamu mencampur `where` dan `orWhere`. Hasilnya bisa membingungkan karena urutan eksekusi.

    Contoh Masalah:
    `where A -> where B -> orWhere C`
    Database akan membacanya sebagai: `(A AND B) OR C`.

    Jika kamu ingin `A AND (B OR C)`, kamu harus menggunakan Parameter Grouping (Closure):

    ```php
    Product::where('price', '>', 100000)
        ->where(function ($query) {
            $query->where('is_active', 1)
                ->orWhere('is_featured', 1);
        })->get();

    ```

    Apakah query "irisan" ini rencananya akan kamu gunakan untuk fitur filter di halaman katalog produkmu?
</pre>




<br> <br>

<hr>

<br> <br>





<pre>
    ğŸ“˜ Apa Itu Relasi di Eloquent?

    Relasi adalah:

    Hubungan antar tabel yang direpresentasikan melalui Model.

    Karena di dunia nyata, data itu tidak berdiri sendiri.

    Contoh:

    User punya banyak Post

    Post punya banyak Comment

    Product punya Category

    Order punya User

    Itu semua adalah relasi.

    
    
    
    
    
    
    ğŸ§  Kenapa Relasi Itu Penting?

    Bayangkan tanpa relasi.

    Untuk ambil:

    Nama user

    Semua post miliknya

    Dan semua comment di tiap post

    Kamu harus tulis SQL join panjang ğŸ˜µ

    Dengan Eloquent?

    Cuma:

    $user->posts


    Atau bahkan:

    $user->posts->first()->comments


    ğŸ”¥ Clean banget.

    
    
    
    
    
    
    ğŸ§± Cara Kerja Relasi di Laravel

    Relasi ditulis di dalam Model.

    Contoh sederhana:

    class User extends Model
    {
        public function posts()
        {
            return $this->hasMany(Post::class);
        }
    }


    Artinya:
    User punya banyak Post.

    Sekarang kita bisa:

    $user = User::find(1);
    $user->posts;


    Tanpa tulis JOIN manual.

    
    
    
    
    
    
    ğŸ§  Relasi Itu Sebenarnya Apa di Database?

    Secara database:

    Relasi = Foreign Key

    Contoh:

    Tabel users

    id
    name


    Tabel posts

    id
    title
    user_id


    Kolom user_id adalah penghubungnya.

    Eloquent hanya membungkus itu jadi lebih manusiawi.

    
    
    
    
    
    
    ğŸ¯ Apa Saja Jenis Relasi di Eloquent?

    Secara umum ada 5 kategori besar:

    1ï¸âƒ£ One to One
    2ï¸âƒ£ One to Many
    3ï¸âƒ£ Many to Many
    4ï¸âƒ£ Has Many Through
    5ï¸âƒ£ Polymorphic

    Tapi untuk 90% project, cukup kuasai:

    One to One

    One to Many

    Many to Many

    
    
    
    
    
    
    ğŸ§  Kenapa Relasi di Eloquent Powerful?

    Karena:

    âœ… Tidak perlu JOIN manual
    âœ… Bisa eager loading
    âœ… Bisa nested relation
    âœ… Bisa hitung otomatis (withCount)
    âœ… Bisa filtering lewat relasi
    âœ… Bisa chaining

    Contoh advanced:

    User::with('posts.comments')->get();


    Itu ambil:

    Semua user

    Semua post mereka

    Semua comment di tiap post

    Dengan 1 baris.

    
    
    
    
    
    
    âš¡ Lazy Loading vs Eager Loading

    Ini penting banget.

    ğŸ”¹ Lazy Loading
    $user = User::find(1);
    $user->posts;


    Query dijalankan saat dipanggil.

    ğŸ”¹ Eager Loading
    User::with('posts')->get();


    Query langsung ambil relasi.

    Kenapa ini penting?
    Karena bisa menghindari N+1 Query Problem.

    
    
    
    
    
    
    ğŸ§  Mental Model Relasi

    Bayangkan Model itu seperti manusia.

    Kalau tanpa relasi:
    Dia tidak tahu siapa temannya.

    Dengan relasi:
    Dia tahu:

    Anak-anaknya

    Orang tuanya

    Teman-temannya

    Eloquent membuat model bisa â€œmengenalâ€ model lain.

    
    
    
    
    
    
    ğŸ Kesimpulan Besar

    Relasi di Eloquent adalah:

    Sistem untuk menghubungkan model dengan model lain secara otomatis berdasarkan foreign key.

    Dan ini yang bikin Laravel:

    Lebih clean

    Lebih readable

    Lebih powerful
</pre>




<br> <br>

<hr>

<br> <br>




<pre>
    ğŸ‘‰ One to One (Satu ke Satu)
    ğŸ§  1ï¸âƒ£ Apa Itu One to One?

    One to One artinya:

    Satu data di tabel A berhubungan dengan satu data di tabel B.

    Contoh real:

    1 User punya 1 Profile

    1 Siswa punya 1 Kartu Pelajar

    1 Produk punya 1 Detail Produk

    Bukan banyak.
    Bukan koleksi.
    Tapi satu pasangan saja.

    
    
    
    
    
    ğŸ§± 2ï¸âƒ£ Contoh Struktur Database

    Misalnya:

    Tabel users
    id
    name
    email

    Tabel profiles
    id
    user_id
    address
    phone


    Kolom user_id adalah foreign key.

    Artinya:
    Profile milik 1 user.

    
    
    
    
    
    ğŸ§  3ï¸âƒ£ Cara Buat Relasi di Model
    ğŸ”¹ Di Model User
    use App\Models\Profile;

    public function profile()
    {
        return $this->hasOne(Profile::class);
    }


    Artinya:
    User punya 1 Profile.

    ğŸ”¹ Di Model Profile
    use App\Models\User;

    public function user()
    {
        return $this->belongsTo(User::class);
    }


    Artinya:
    Profile milik 1 User.

    
    
    
    
    
    ğŸ§  4ï¸âƒ£ Kenapa Ada hasOne & belongsTo?

    Karena:

    hasOne() â†’ dari sisi pemilik

    belongsTo() â†’ dari sisi yang punya foreign key

    Rule mudahnya:

    Kalau tabel punya user_id
    Maka dia pakai belongsTo(User::class)

    
    
    
    
    
    ğŸš€ 5ï¸âƒ£ Cara Menggunakan Relasi
    Ambil profile dari user
    $user = User::find(1);
    $user->profile;


    Tanpa JOIN manual ğŸ”¥

    Ambil user dari profile
    $profile = Profile::find(1);
    $profile->user;

    
    
    
    
    
    ğŸ”¥ 6ï¸âƒ£ Cara Simpan Data Lewat Relasi

    Contoh:

    $user = User::find(1);

    $user->profile()->create([
        'address' => 'Jakarta',
        'phone' => '08123456789'
    ]);


    Laravel otomatis isi user_id.

    
    
    
    
    
    ğŸ§  7ï¸âƒ£ Eager Loading (Penting!)

    Kalau ambil banyak user:

    User::with('profile')->get();


    Lebih efisien daripada:

    User::all();


    Lalu akses profile satu-satu.

    
    
    
    
    
    ğŸ§  8ï¸âƒ£ Custom Foreign Key (Kalau Nama Berbeda)

    Default Laravel cari:

    user_id


    Kalau berbeda:

    return $this->hasOne(Profile::class, 'custom_user_id');


    Format:

    hasOne(ModelTujuan, foreign_key, local_key)

    
    
    
    
    
    ğŸ¯ 9ï¸âƒ£ Kapan Pakai One to One?

    Kalau:

    Data terlalu panjang dan ingin dipisah

    Data jarang diakses

    Ingin modular

    Contoh:
    User basic info di users
    Detail tambahan di profiles

    ğŸ Kesimpulan

    One to One adalah:

    Hubungan 1 data â†” 1 data

    Method utama:

    hasOne()

    belongsTo()

    Dan ini dasar dari semua relasi lain.
</pre>




<br> <br>

<hr>

<br> <br>





<pre>
    ğŸ‘‰ One to Many (Satu ke Banyak)
    ğŸ§  1ï¸âƒ£ Apa Itu One to Many?

    One to Many artinya:

    Satu data di tabel A punya banyak data di tabel B.

    Contoh real:

    1 User punya banyak Post

    1 Post punya banyak Comment

    1 Category punya banyak Product

    1 Order punya banyak Order Item

    Ini relasi yang PALING sering dipakai di project Laravel.

    
    
    
    
    
    ğŸ§± 2ï¸âƒ£ Contoh Struktur Database

    Misalnya:

    Tabel users
    id
    name
    email

    Tabel posts
    id
    title
    content
    user_id


    user_id adalah foreign key.

    Artinya:
    Setiap post milik 1 user.
    Tapi 1 user bisa punya banyak post.

    
    
    
    
    
    ğŸ§  3ï¸âƒ£ Cara Buat Relasi di Model
    ğŸ”¹ Di Model User (Parent)
    use App\Models\Post;

    public function posts()
    {
        return $this->hasMany(Post::class);
    }


    Artinya:
    User punya banyak Post.

    ğŸ”¹ Di Model Post (Child)
    use App\Models\User;

    public function user()
    {
        return $this->belongsTo(User::class);
    }


    Artinya:
    Post milik 1 User.

    
    
    
    
    
    ğŸ§  4ï¸âƒ£ Kenapa Namanya hasMany?

    Karena:

    Parent â†’ hasMany()

    Child â†’ belongsTo()

    Rule gampang:

    Yang punya foreign key â†’ belongsTo()
    Yang tidak punya foreign key â†’ hasMany()

    
    
    
    
    
    ğŸš€ 5ï¸âƒ£ Cara Menggunakan Relasi
    Ambil semua post milik user
    $user = User::find(1);
    $user->posts;


    Return: Collection

    Looping di Blade
    @foreach ($user->posts as $post)
        {{ $post->title }}
    @endforeach

    Ambil user dari post
    $post = Post::find(1);
    $post->user;

    
    
    
    
    
    ğŸ”¥ 6ï¸âƒ£ Simpan Data Lewat Relasi

    Lebih clean daripada isi user_id manual.

    $user = User::find(1);

    $user->posts()->create([
        'title' => 'Belajar Laravel',
        'content' => 'Laravel itu menyenangkan'
    ]);


    Laravel otomatis isi user_id.

    
    
    
    
    
    âš¡ 7ï¸âƒ£ Eager Loading (WAJIB TAHU)

    Kalau kita ambil banyak user:

    âŒ Cara buruk (Lazy Loading):

    $users = User::all();

    foreach ($users as $user) {
        $user->posts;
    }


    Ini bisa bikin N+1 problem.

    âœ… Cara benar (Eager Loading):

    User::with('posts')->get();


    Query lebih efisien.

    
    
    
    
    
    ğŸ§  8ï¸âƒ£ Filtering Lewat Relasi

    Ambil user yang punya post:

    User::has('posts')->get();


    Ambil user dengan minimal 3 post:

    User::has('posts', '>=', 3)->get();


    ğŸ”¥ Powerful banget.

    
    
    
    
    
    ğŸ§  9ï¸âƒ£ Hitung Jumlah Relasi
    User::withCount('posts')->get();


    Sekarang bisa akses:

    $user->posts_count;


    Tanpa query manual.

    
    
    
    
    
    ğŸ¯ 10ï¸âƒ£ Kapan Pakai One to Many?

    Kalau:

    Satu data jadi â€œindukâ€

    Data lain jadi â€œanakâ€

    Jumlah anak bisa banyak

    Contoh paling klasik:

    User â†’ Posts
    Posts â†’ Comments

    Itu nested One to Many.

    
    
    
    
    
    ğŸ Kesimpulan

    One to Many adalah:

    Relasi paling umum dan paling sering dipakai di Laravel.

    Method utama:

    hasMany()

    belongsTo()

    Dan hampir semua aplikasi web pasti pakai ini.






    ADDITIONAL 1:
    QUESTION: pada kode berikut:
    Ambil user dengan minimal 3 post:
    User::has('posts', '>=', 3)->get();

    mengapa tidak menggunakan with atau where?






    Ini adalah pertanyaan yang sangat bagus untuk memahami perbedaan antara memfilter data berdasarkan hubungan dan memuat data hubungan itu sendiri.

    Meskipun terlihat mirip, `has()`, `with()`, dan `whereHas()` memiliki tugas yang sangat berbeda di balik layar.

    ---

    ### 1. Mengapa bukan `with()`?

    `with()` digunakan untuk Eager Loading, yaitu menarik data hubungan agar tidak terjadi masalah *N+1 Query*. `with()` tidak memfilter induknya.

    * Jika kamu pakai `with('posts')`: Kamu akan mendapatkan semua user, baik yang punya 0 post maupun 100 post. Bedanya, data post-nya sudah "ikut" di dalam objek user.
    * Tujuan `has()`: Membuang user yang tidak memenuhi kriteria jumlah hubungan.

    ---

    ### 2. Mengapa bukan `where()` biasa?

    `where()` digunakan untuk mengecek kolom yang ada di dalam tabel User itu sendiri (seperti `email` atau `status`).

    * `where()` tidak bisa langsung menghitung jumlah baris di tabel lain (`posts`).
    * Jika kamu menulis `User::where('posts', '>=', 3)`, Laravel akan error karena ia mencari kolom bernama `posts` di tabel `users`, padahal data tersebut ada di tabel lain.

    ---

    ### 3. Apa bedanya dengan `whereHas()`?

    Sebenarnya `has()` adalah versi sederhana dari `whereHas()`.

    * `has('posts', '>=', 3)`: Digunakan jika kamu hanya peduli pada jumlah (kuantitas). "Pokoknya saya mau user yang punya minimal 3 post, terserah isi post-nya apa."
    * `whereHas()`: Digunakan jika kamu ingin memfilter berdasarkan kondisi (kualitas) isi post-nya.

    Contoh `whereHas`:
    "Ambil user yang punya minimal 3 post yang statusnya 'published'."

    ```php
    User::whereHas('posts', function ($query) {
        $query->where('status', 'published');
    }, '>=', 3)->get();

    ```

    ---

    ### 4. Bagaimana Laravel melakukannya di SQL?

    Saat kamu menjalankan `User::has('posts', '>=', 3)`, Laravel tidak mengambil semua data lalu menghitungnya di PHP (itu akan sangat lambat). Laravel menggunakan subquery yang sangat efisien:

    ```sql
    SELECT * FROM users 
    WHERE (
        SELECT COUNT(*) FROM posts WHERE posts.user_id = users.id
    ) >= 3;

    ```

    ---

    ### Ringkasan Cepat:

    | Method | Kegunaan | Analogi |
    | --- | --- | --- |
    | `has()` | Filter berdasarkan jumlah hubungan. | "Saya mau cari bapak yang punya minimal 3 anak." |
    | `whereHas()` | Filter berdasarkan kriteria/isi hubungan. | "Saya mau cari bapak yang punya minimal 3 anak yang sudah kuliah." |
    | `with()` | Membawa data hubungan (tidak memfilter). | "Saya mau panggil semua bapak, dan tolong bawa serta anak-anaknya kalau ada." |

    ### ğŸ’¡ Tips Pro:

    Jika kamu ingin mendapatkan user dengan minimal 3 post DAN ingin menampilkan post-post tersebut di halaman web, maka kamu harus menggabungkannya:

    ```php
    User::has('posts', '>=', 3)->with('posts')->get();

    ```

    Tanpa `with()`, meskipun kamu dapat usernya, data post-nya masih kosong sampai kamu memanggilnya secara manual.

    Apakah kamu berencana menampilkan jumlah post ini di samping nama user pada tampilan (UI) nanti? Jika iya, kamu mungkin juga butuh `withCount('posts')`.








    ADDITIONAL 2:
    QUESTION: has, whereHas dan lain sebagainya ini termasuk dalam materi apa?



    Method seperti `has()`, `whereHas()`, `with()`, dan `withCount()` masuk ke dalam materi besar bernama Eloquent Relationships (Relasi Eloquent).

    Secara lebih spesifik, method-method yang kamu sebutkan tadi berada di bawah sub-materi Querying Relationship Existence (Menanyakan Keberadaan Relasi).

    ---

    ### Peta Materi Eloquent Relationship

    Agar belajarnya lebih terstruktur, materi relasi di Laravel biasanya dibagi menjadi tiga bagian utama:

    #### 1. Defining Relationships (Mendefinisikan Relasi)

    Ini adalah tahap awal di mana kamu menuliskan kode di dalam Model untuk menyambungkan satu tabel dengan tabel lainnya.

    * *Keywords:* `hasOne`, `hasMany`, `belongsTo`, `belongsToMany`.

    #### 2. Querying Relationship Existence (Filter Berdasarkan Relasi)

    Nah, di sinilah letak `has()` dan `whereHas()`. Materinya fokus pada cara memfilter data induk berdasarkan kondisi di tabel anak.

    * `has()`: Filter berdasarkan jumlah (kuantitas).
    * `whereHas()`: Filter berdasarkan kriteria (kualitas/isi).
    * `doesntHave()`: Kebalikan dari `has` (mencari yang tidak punya hubungan).
    * `whereDoesntHave()`: Kebalikan dari `whereHas`.

    #### 3. Eager Loading (Mengambil Data Relasi)

    Materi ini fokus pada bagaimana cara menarik data anak agar efisien dan tidak membebani database (menghindari masalah *N+1 Query*).

    * *Keywords:* `with()`, `load()`, `withCount()`.

    ---

    ### Mengapa Materi ini Penting?

    Tanpa memahami materi Querying Relationship Existence, kamu akan cenderung melakukan cara "manual" yang tidak efisien, seperti:

    1. Mengambil semua data User.
    2. Melakukan *looping* (foreach) di PHP.
    3. Menghitung post satu per satu.
    4. Menghapus User yang post-nya kurang dari 3.

    Cara manual ini akan membuat aplikasi kamu sangat lambat jika data sudah mencapai ribuan. Dengan menggunakan `has()` atau `whereHas()`, semua proses filter tersebut dilakukan di dalam database sebelum datanya dikirim ke PHP.

    ---

    ### Tips Belajar:

    Jika kamu ingin mendalami ini di dokumentasi resmi Laravel, kamu bisa mencarinya di bagian "Eloquent: Relationships" pada bagian menu:

    * *Querying Relations*
    * *Querying Relationship Existence*
    * *Querying Relationship Absence*

    Apakah kamu merasa lebih mudah memahami logika filter ini lewat `has()` dibandingkan menggunakan SQL manual (Join)? Kebanyakan orang merasa `whereHas` jauh lebih "manusiawi" untuk dibaca! ğŸ˜„
</pre>




<br> <br>

<hr> 

<br> <br>




<pre>
    ğŸ‘‰ Many to Many (Relasi dengan Pivot Table)

    Ini dipakai di hampir semua aplikasi besar.

    
    
    
    
    
    
    ğŸ§  1ï¸âƒ£ Apa Itu Many to Many?

    Many to Many artinya:

    Banyak data di tabel A berhubungan dengan banyak data di tabel B.

    Contoh real:

    1 User bisa punya banyak Role

    1 Role bisa dimiliki banyak User

    1 Product bisa punya banyak Tag

    1 Tag bisa dipakai banyak Product

    Itu bukan One to Many.
    Karena dua-duanya bisa banyak.

    
    
    
    
    
    
    ğŸ§± 2ï¸âƒ£ Struktur Database

    Misalnya:

    Tabel users
    id
    name

    Tabel roles
    id
    name


    Karena tidak bisa langsung relasi, kita butuh:

    Tabel Pivot role_user
    id
    user_id
    role_id


    Pivot table ini yang menghubungkan mereka.

    
    
    
    
    
    
    ğŸ§  3ï¸âƒ£ Kenapa Perlu Pivot Table?

    Karena:

    User tidak bisa menyimpan banyak role_id dalam 1 kolom.
    Role juga tidak bisa menyimpan banyak user_id dalam 1 kolom.

    Solusinya:
    Tabel perantara.

    
    
    
    
    
    
    ğŸ§  4ï¸âƒ£ Cara Buat Relasi di Model
    ğŸ”¹ Di Model User
    use App\Models\Role;

    public function roles()
    {
        return $this->belongsToMany(Role::class);
    }

    ğŸ”¹ Di Model Role
    use App\Models\User;

    public function users()
    {
        return $this->belongsToMany(User::class);
    }


    âš  Many to Many selalu pakai belongsToMany() di kedua sisi.

    
    
    
    
    
    
    ğŸ§  5ï¸âƒ£ Aturan Nama Pivot Table

    Default Laravel:

    nama_model_urut_abjad_singular


    Contoh:
    role_user (bukan user_role)

    Karena:
    r lebih dulu dari u.

    Kalau nama berbeda:

    return $this->belongsToMany(Role::class, 'custom_pivot_table');

    
    
    
    
    
    
    ğŸš€ 6ï¸âƒ£ Cara Menggunakan Relasi
    Ambil semua role milik user
    $user = User::find(1);
    $user->roles;


    Return: Collection

    Ambil semua user milik role
    $role = Role::find(1);
    $role->users;

    
    
    
    
    
    
    ğŸ”¥ 7ï¸âƒ£ Menambahkan Relasi (Attach)
    $user = User::find(1);
    $user->roles()->attach(2);


    Artinya:
    Tambahkan role dengan id 2 ke user tersebut.

    Attach banyak sekaligus
    $user->roles()->attach([1, 2, 3]);

    âŒ Melepas Relasi (Detach)
    $user->roles()->detach(2);

    ğŸ”„ Sync (Update Relasi Sekaligus)
    $user->roles()->sync([1, 3]);


    Artinya:
    Hanya role 1 dan 3 yang tersisa.
    Yang lain dihapus otomatis.

    ğŸ”¥ Ini sering dipakai di form checkbox.

    
    
    
    
    
    
    ğŸ§  8ï¸âƒ£ Pivot dengan Kolom Tambahan

    Kadang pivot punya kolom ekstra.

    Contoh:

    order_product
    order_id
    product_id
    quantity
    price


    Di model:

    return $this->belongsToMany(Product::class)
                ->withPivot('quantity', 'price');


    Sekarang bisa akses:

    $product->pivot->quantity;


    ğŸ”¥ Powerful banget.

    
    
    
    
    
    
    âš¡ 9ï¸âƒ£ Eager Loading
    User::with('roles')->get();


    Sama seperti relasi lain.

    
    
    
    
    
    
    ğŸ¯ 10ï¸âƒ£ Kapan Pakai Many to Many?

    Kalau:

    Dua tabel sama-sama bisa punya banyak relasi

    Hubungan fleksibel

    Tidak bisa pakai foreign key langsung

    Contoh umum:

    User â†” Role
    Post â†” Tag
    Order â†” Product

    
    
    
    
    
    
    ğŸ§  Perbandingan Singkat Semua Relasi
    Relasi	Foreign Key	Pivot Table
    One to One	Ya	Tidak
    One to Many	Ya	Tidak
    Many to Many	Tidak langsung	Ya
    ğŸ Kesimpulan

    Many to Many adalah:

    Relasi banyak ke banyak yang membutuhkan tabel pivot.

    Method penting:

    belongsToMany()

    attach()

    detach()

    sync()

    withPivot()

    Dan ini bikin aplikasi jadi fleksibel banget.







    ADDITIONAL 1:
    QUESTION: jadi saat pivot tabel menggunakan laravel, laravel otomatis menggunakan table dengan nama gabungan antara kedua table dengan urutan abjad ketika dua model tersebut dihubungkan dengan belongToMany atau kita bisa menyisipkan nama table (jika berbeda setelah parameter nama classnya) ya?



    Tepat sekali! Kamu sudah memahami Konvensi vs Konfigurasi di Laravel dengan sangat baik.

    Laravel memang dirancang agar kita tidak perlu menulis banyak kode jika kita mengikuti aturan penamaannya. Namun, Laravel juga sangat fleksibel jika kita ingin melanggar aturan tersebut.

    Berikut detail logikanya:

    ---

    ### 1. Aturan Standar (Convention)

    Jika kamu tidak menyebutkan nama tabel pivot, Laravel akan:

    1. Mengambil nama kedua model dalam bentuk singular (tunggal).
    2. Mengurutkannya sesuai abjad.
    3. Menggabungkannya dengan garis bawah (`_`).

    Contoh Kasus:
    Jika kamu punya model `Merchant` dan model `Product`:

    * Urutan abjad: `M` (Merchant) datang sebelum `P` (Product).
    * Nama tabel pivot otomatis: `merchant_product`.

    ---

    ### 2. Kustomisasi Nama Tabel (Configuration)

    Jika tabel pivot kamu namanya tidak standar (misal: `daftar_barang_toko` atau `merchant_items`), kamu tinggal menyisipkannya sebagai parameter kedua di dalam method `belongsToMany`.

    ```php
    // Di dalam model Merchant.php
    public function products()
    {
        return $this->belongsToMany(Product::class, 'merchant_items');
    }

    ```

    ---

    ### 3. Kustomisasi Nama Kolom (Foreign Keys)

    Terkadang, masalah tidak hanya di nama tabel, tapi juga di nama kolom di dalam tabel pivot tersebut. Secara default, Laravel mencari `merchant_id` dan `product_id`.

    Jika nama kolommu juga berbeda (misal: `id_pedagang` dan `id_barang`), kamu bisa menambahkannya di parameter ketiga dan keempat:

    ```php
    return $this->belongsToMany(
        Product::class,     // Model tujuan
        'merchant_items',   // Nama tabel pivot
        'id_pedagang',      // FK model ini (Merchant) di tabel pivot
        'id_barang'         // FK model tujuan (Product) di tabel pivot
    );

    ```

    ---

    ### 4. Hal Penting Saat Membuat Migration Pivot

    Ingat, karena tabel pivot adalah tabel "penghubung", saat kamu membuat migration-nya, kamu tidak butuh model sendiri (biasanya). Cukup buat migration tabel biasa:

    ```bash
    php artisan make:migration create_merchant_product_table

    ```

    Dan pastikan di dalamnya kamu menggunakan `foreignId` yang merujuk ke kedua tabel induk:

    ```php
    Schema::create('merchant_product', function (Blueprint $table) {
        $table->id();
        $table->foreignId('merchant_id')->constrained()->onDelete('cascade');
        $table->foreignId('product_id')->constrained()->onDelete('cascade');
        // Jika ingin ada timestamp di pivot, tambahkan ini
        $table->timestamps(); 
    });

    ```

    ---

    ### ğŸ’¡ Tips Pro: Mengakses Data di Tabel Pivot

    Jika tabel pivot kamu punya kolom tambahan (misal: kolom `jumlah` atau `keterangan`), jangan lupa tambahkan `withPivot` di Model agar Laravel bisa membacanya:

    ```php
    return $this->belongsToMany(Product::class)->withPivot('jumlah', 'keterangan');

    ```

    Lalu kamu bisa mengaksesnya lewat: `$product->pivot->jumlah`.

    Kesimpulan:
    Laravel akan selalu mencoba menebak nama tabelmu secara alfabetis (`a_b`). Jika tebakannya salah karena kamu punya nama sendiri, tinggal "bisikkan" nama tabelnya di parameter kedua.

    Sejauh ini, apakah kamu lebih suka mengikuti aturan abjad Laravel atau lebih suka menentukan nama tabel sendiri agar lebih jelas?
</pre>






<br> <br>

<hr>

<br> <br>




<pre>
    ğŸ‘‰ Querying Relationship Existence

    Ini dipakai kalau kita ingin:

    Mengecek apakah suatu model punya relasi tertentu.

    Bukan cuma ambil relasinya,
    tapi filter berdasarkan keberadaan relasi.

    Ini sering banget dipakai di aplikasi real.

    
    
    
    
    
    
    
    ğŸ§  1ï¸âƒ£ Apa Itu Relationship Existence?

    Contoh kasus:

    Ambil user yang punya post

    Ambil post yang punya comment

    Ambil product yang punya category

    Ambil user yang tidak punya role

    Itu semua bukan soal ambil relasi,
    tapi soal mengecek keberadaannya.

    
    
    
    
    
    
    
    ğŸ”¥ 2ï¸âƒ£ Method has()
    ğŸ“Œ Ambil model yang PUNYA relasi

    Contoh:

    User::has('posts')->get();


    Artinya:

    Ambil semua user yang punya minimal 1 post

    Dengan jumlah minimum
    User::has('posts', '>=', 3)->get();


    Artinya:

    Ambil user yang punya minimal 3 post

    
    
    
    
    
    
    
    ğŸ”¥ 3ï¸âƒ£ whereHas()

    Kalau kita mau filter relasi berdasarkan kondisi.

    Contoh:

    User::whereHas('posts', function ($query) {
        $query->where('title', 'like', '%Laravel%');
    })->get();


    Artinya:

    Ambil user yang punya post dengan judul mengandung "Laravel"

    ğŸ”¥ Ini sangat powerful.

    
    
    
    
    
    
    
    ğŸ”¥ 4ï¸âƒ£ doesntHave()

    Ambil model yang TIDAK punya relasi.

    User::doesntHave('posts')->get();


    Artinya:

    Ambil user yang belum pernah bikin post

    
    
    
    
    
    
    
    ğŸ”¥ 5ï¸âƒ£ whereDoesntHave()

    Versi dengan kondisi:

    User::whereDoesntHave('posts', function ($query) {
        $query->where('is_published', true);
    })->get();


    Artinya:

    Ambil user yang tidak punya post yang published

    
    
    
    
    
    
    
    ğŸ§  6ï¸âƒ£ Nested Relationship

    Misalnya:

    User â†’ Posts â†’ Comments

    Kita bisa cek nested relasi:

    User::has('posts.comments')->get();


    Artinya:

    Ambil user yang punya post DAN post itu punya comment

    Dengan kondisi nested:
    User::whereHas('posts.comments', function ($query) {
        $query->where('content', 'like', '%Bagus%');
    })->get();


    ğŸ”¥ Ini sudah level production app.

    
    
    
    
    
    
    
    ğŸ§  7ï¸âƒ£ withCount() (Bonus Penting)

    Kadang kita ingin tahu jumlah relasi.

    User::withCount('posts')->get();


    Sekarang bisa akses:

    $user->posts_count;


    Tanpa query tambahan.

    Dengan kondisi:
    User::withCount(['posts' => function ($query) {
        $query->where('is_published', true);
    }])->get();

    
    
    
    
    
    
    
    ğŸ¯ 8ï¸âƒ£ Studi Kasus Nyata

    Misalnya sistem blog.

    Ambil kategori yang punya minimal 5 artikel:

    Category::has('posts', '>=', 5)->get();


    Ambil artikel yang punya komentar:

    Post::has('comments')->get();


    Ambil artikel tanpa komentar:

    Post::doesntHave('comments')->get();


    Ini sering dipakai untuk dashboard.

    
    
    
    
    
    
    
    ğŸ§  Kenapa Ini Powerful?

    Karena tanpa ini kamu harus tulis:

    JOIN
    GROUP BY
    HAVING
    COUNT()


    Dengan Eloquent?
    Cuma 1 baris.

    ğŸ Ringkasan Method Penting
    Method	Fungsi
    has()	Ada relasi
    whereHas()	Ada relasi + kondisi
    doesntHave()	Tidak ada relasi
    whereDoesntHave()	Tidak ada relasi + kondisi
    withCount()	Hitung relasi
    
    
    
    
    
    
    
    ğŸ”¥ Kesimpulan

    Querying Relationship Existence membuat kita bisa:

    Filter berdasarkan relasi

    Hindari query SQL kompleks

    Bangun fitur dashboard & statistik dengan mudah

    Ini sudah masuk level intermediate Laravel.
</pre>




<br> <br>

<hr>

<br> <br>




<pre>
    ğŸ‘‰ Eager Loading & N+1 Problem

    Ini bukan soal fitur.
    Ini soal performa âš¡

    
    
    
    
    
    
    
    ğŸ§  1ï¸âƒ£ Apa Itu N+1 Problem?

    Contoh kasus:

    Kita punya:

    10 user

    Setiap user punya banyak post

    Kita tulis:

    $users = User::all();

    foreach ($users as $user) {
        $user->posts;
    }


    Kelihatannya normal ya?

    Tapi yang terjadi di belakang layar:

    1 query untuk ambil users

    10 query untuk ambil posts tiap user

    Total = 11 query ğŸ˜±

    Kalau user ada 100?

    1 + 100 = 101 query

    Itulah yang disebut:

    N+1 Problem

    N = jumlah data

    1 query awal

    Ini bikin aplikasi lambat banget.

    
    
    
    
    
    
    
    ğŸ”¥ 2ï¸âƒ£ Solusi: Eager Loading

    Gunakan:

    User::with('posts')->get();


    Sekarang yang terjadi:

    1 query ambil users
    1 query ambil semua posts yang terkait

    Total = 2 query saja ğŸ”¥

    Jauh lebih efisien.

    
    
    
    
    
    
    
    ğŸ§  3ï¸âƒ£ Perbedaan Lazy vs Eager
    âŒ Lazy Loading

    Relasi dipanggil setelah model diambil.

    $user->posts;


    Query dijalankan saat itu juga.

    âœ… Eager Loading

    Relasi diambil di awal.

    User::with('posts')->get();


    Query lebih sedikit dan lebih cepat.

    
    
    
    
    
    
    
    ğŸ§  4ï¸âƒ£ Eager Loading Multiple Relasi

    Misalnya:

    User â†’ Posts â†’ Comments

    User::with('posts.comments')->get();


    Laravel akan ambil:

    Users

    Posts

    Comments

    Dengan query teroptimasi.

    
    
    
    
    
    
    
    ğŸ”¥ 5ï¸âƒ£ Eager Loading Dengan Kondisi
    User::with(['posts' => function ($query) {
        $query->where('is_published', true);
    }])->get();


    Ambil user + hanya post yang published.

    
    
    
    
    
    
    
    ğŸ§  6ï¸âƒ£ Load Setelah Query (Lazy Eager Loading)

    Kalau sudah ambil data:

    $users = User::all();
    $users->load('posts');


    Ini tetap efisien, tidak N+1.

    
    
    
    
    
    
    
    ğŸ§  7ï¸âƒ£ withCount() (Optimasi Statistik)

    Daripada ambil semua post:

    User::withCount('posts')->get();


    Lebih ringan daripada:

    $user->posts->count();

    
    
    
    
    
    
    
    ğŸ§  8ï¸âƒ£ Cara Tahu Terkena N+1 Problem?

    Saat development:

    Query terlalu banyak

    Debugbar menunjukkan banyak query

    Halaman terasa lambat

    Biasanya karena lupa with().

    
    
    
    
    
    
    
    ğŸ¯ 9ï¸âƒ£ Studi Kasus Real

    Dashboard admin:

    Menampilkan:

    Nama user

    Jumlah post

    Jumlah comment

    Cara optimal:

    User::withCount(['posts', 'comments'])->get();


    Tanpa N+1.
    Tanpa loop query.

    
    
    
    
    
    
    
    âš¡ 10ï¸âƒ£ Kapan WAJIB Pakai Eager Loading?

    Kalau:

    Looping data

    Menampilkan relasi di blade

    Dashboard statistik

    API response nested

    Rule simpel:

    Kalau kamu pakai relasi di dalam loop
    â¡ Gunakan with()

    
    
    
    
    
    
    
    ğŸ§  Mental Model

    Lazy Loading:
    Ambil data satu-satu.

    Eager Loading:
    Ambil sekaligus.

    Seperti belanja:

    Lazy = bolak-balik toko

    Eager = beli semua sekaligus

    
    
    
    
    
    
    
    ğŸ Kesimpulan

    Eager Loading:

    âœ… Menghindari N+1 Problem
    âœ… Mengurangi jumlah query
    âœ… Membuat aplikasi scalable
    âœ… Wajib di project besar

    Kalau kamu paham ini,
    kamu sudah selangkah lebih dekat ke level backend serius ğŸ”¥
</pre>



<br> <br>

<hr>

<br> <br>




<pre>
    ğŸ‘‰ 5ï¸âƒ£ Mass Assignment

    Ini sering bikin error pemula ğŸ˜…
    Tapi juga jadi sistem keamanan penting di Laravel.

    
    
    
    
    
    
    
    ğŸ§  1ï¸âƒ£ Apa Itu Mass Assignment?

    Mass assignment adalah:

    Mengisi banyak kolom sekaligus dalam satu array.

    Contoh:

    Product::create([
        'name' => 'Laptop',
        'price' => 10000000
    ]);


    Kita langsung kirim array â†’ Laravel isi kolom sekaligus.

    Itulah mass assignment.

    
    
    
    
    
    
    
    ğŸ”¥ 2ï¸âƒ£ Kenapa Laravel Membatasi Ini?

    Karena masalah keamanan âš 

    Bayangkan ada form:

    <input name="name">
    <input name="price">


    Tapi user nakal menambahkan:

    <input name="is_admin" value="1">


    Kalau tidak ada proteksiâ€¦

    User::create($request->all());


    Maka kolom is_admin bisa ikut terisi ğŸ˜±

    Itu bahaya.

    
    
    
    
    
    
    
    ğŸ›¡ 3ï¸âƒ£ Solusi: $fillable

    Di model:

    class Product extends Model
    {
        protected $fillable = ['name', 'price'];
    }


    Artinya:

    Hanya kolom ini yang boleh diisi mass assignment.

    Kalau ada field lain dikirim?
    Laravel akan tolak.

    
    
    
    
    
    
    
    ğŸ”’ 4ï¸âƒ£ Alternatif: $guarded

    Kebalikannya.

    protected $guarded = ['id'];


    Artinya:

    Semua kolom boleh diisi kecuali id.

    âš  Best Practice

    Gunakan $fillable
    Lebih aman dan eksplisit.

    
    
    
    
    
    
    
    ğŸš« 5ï¸âƒ£ Error Umum Pemula

    Kalau kamu lupa set $fillable lalu pakai:

    Product::create([...]);


    Akan muncul error:

    MassAssignmentException


    Itu bukan bug.
    Itu sistem keamanan Laravel bekerja.

    
    
    
    
    
    
    
    ğŸ§  6ï¸âƒ£ create() vs save()

    Mass assignment terjadi di:

    Model::create([...]);


    Dan:

    $model->update([...]);


    Kalau pakai cara manual:

    $product = new Product;
    $product->name = 'Laptop';
    $product->price = 10000000;
    $product->save();


    Ini bukan mass assignment.
    Ini manual assignment.
    Tidak butuh $fillable.

    
    
    
    
    
    
    
    ğŸ”¥ 7ï¸âƒ£ Contoh Real di Controller
    public function store(Request $request)
    {
        Product::create($request->all());
    }


    Kalau model tidak ada $fillable
    â¡ Error

    Kalau ada $fillable
    â¡ Aman

    
    
    
    
    
    
    
    ğŸ§  8ï¸âƒ£ Mass Assignment + Validation (Best Practice)

    Jangan langsung:

    Product::create($request->all());


    Lebih aman:

    $validated = $request->validate([
        'name' => 'required',
        'price' => 'required|numeric'
    ]);

    Product::create($validated);


    Sekarang:
    âœ” Sudah divalidasi
    âœ” Sudah difilter oleh fillable
    âœ” Aman

    
    
    
    
    
    
    
    ğŸš€ 9ï¸âƒ£ Force Fill (Jarang Dipakai)

    Kalau benar-benar ingin bypass proteksi:

    $model->forceFill([...])->save();


    Tapi ini jarang dipakai dan berisiko.

    
    
    
    
    
    
    
    ğŸ¯ 10ï¸âƒ£ Kapan Mass Assignment Dipakai?

    Biasanya saat:

    Simpan form

    Update form

    Seeder

    Factory

    Hampir semua CRUD pakai ini.

    
    
    
    
    
    
    
    ğŸ§  Mental Model

    Mass assignment itu seperti:

    Mengisi formulir otomatis.

    Laravel bilang:

    "Silakan isi, tapi hanya kolom yang saya izinkan."

    
    
    
    
    
    
    
    ğŸ Kesimpulan

    Mass Assignment adalah:

    Cara mengisi banyak kolom sekaligus dengan aman.

    Hal penting:

    âœ” Gunakan $fillable
    âœ” Jangan asal $request->all()
    âœ” Validasi dulu

    Kalau kamu paham ini,
    aplikasimu jauh lebih aman ğŸ”¥





    ADDITIONAL:
    QUSTION: apa itu accessor, mutator, dan casting attribute?


    Dalam ekosistem Laravel Eloquent, ketiga fitur ini adalah "penerjemah" yang berdiri di tengah-tengah antara Database dan Kode PHP kamu. Mereka memastikan data yang keluar-masuk database selalu dalam format yang kamu inginkan tanpa harus mengubah data aslinya.

    ---

    ### 1. Accessor (Si "Penghias" Data)

    Accessor berfungsi untuk mengubah atau memformat data saat kamu mengambilnya dari database. Data di database tetap asli, tapi saat tampil di layar, formatnya sudah cantik.

    * Contoh Kasus: Di database nama tersimpan `budi santoso`. Kamu ingin setiap kali dipanggil, namanya otomatis jadi Huruf Kapital `Budi Santoso`.
    * Cara Kerja: Kamu membuat fungsi di Model dengan awalan `get...Attribute`.

    ```php
    // Laravel versi lama
    public function getNameAttribute($value) {
        return ucwords($value);
    }

    // Laravel versi baru (Attribute Casting)
    protected function name(): Attribute {
        return Attribute::make(
            get: fn (string $value) => ucwords($value),
        );
    }

    ```

    ---

    ### 2. Mutator (Si "Pengolah" Data)

    Mutator adalah kebalikan dari Accessor. Ia bekerja saat kamu menyimpan data ke database. Ia memastikan data yang masuk ke database seragam.

    * Contoh Kasus: User mengetik password `Rahasia123`. Kamu ingin password tersebut otomatis di-*hash* sebelum masuk ke database agar aman.
    * Cara Kerja: Menggunakan awalan `set...Attribute`.

    ```php
    // Contoh: Memastikan username selalu tersimpan dalam huruf kecil
    protected function username(): Attribute {
        return Attribute::make(
            set: fn (string $value) => strtolower($value),
        );
    }

    ```

    ---

    ### 3. Casting Attribute (Si "Penerjemah" Tipe Data)

    Casting adalah cara paling praktis untuk mengubah tipe data secara otomatis. Database biasanya hanya mengenal tipe data sederhana (string, integer, boolean). Dengan Casting, kamu bisa mengubahnya menjadi tipe data PHP yang lebih kompleks.

    * Contoh Kasus: Kamu punya kolom `is_admin` di database bertipe `TINYINT` (0 atau 1). Kamu ingin di PHP tipe datanya langsung jadi `true` atau `false` (boolean).
    * Pengaturan: Ditulis dalam properti `$casts` di Model.

    ```php
    protected $casts = [
        'is_admin' => 'boolean',
        'published_at' => 'datetime', // Otomatis jadi objek Carbon
        'options' => 'array',         // Otomatis JSON di DB jadi Array di PHP
    ];

    ```

    ---

    ### Perbedaan Utama

    | Fitur | Kapan Beraksi? | Kegunaan Utama |
    | --- | --- | --- |
    | Accessor | Saat Ambil data (`$user->name`) | Memformat tampilan (tgl Indonesia, rupiah, kapital). |
    | Mutator | Saat Simpan data (`$user->save()`) | Standarisasi input (hashing password, slugging). |
    | Casting | Otomatis (Bolak-balik) | Menyelaraskan tipe data (JSON ke Array, String ke Date). |

    ---

    ### ğŸ’¡ Tips Pro: Custom Accessor (Virtual Attribute)

    Kamu bisa membuat Accessor untuk kolom yang tidak ada di database. Misalnya, kamu punya kolom `first_name` dan `last_name`, tapi ingin membuat atribut `full_name`.

    ```php
    protected function fullName(): Attribute {
        return Attribute::make(
            get: fn (mixed $value, array $attributes) => 
                "{$attributes['first_name']} {$attributes['last_name']}",
        );
    }

    ```

    Sekarang kamu bisa memanggil `$user->full_name` seolah-olah kolom itu ada di database!

    Apakah kamu punya data di tabel `products` (misalnya harga) yang ingin diformat otomatis menjadi rupiah menggunakan Accessor?
</pre>

            </div>
        </main>
    </div>
    <script>
        fetch('layout/aside.html').then( response => response.text()).then( data => {
            document.getElementById('aside').innerHTML = data;

            const currentPage = window.location.pathname.split('/').pop() || 'index.html';
            const links = document.querySelectorAll('aside a');

            links.forEach(link => {
                if(currentPage == 'index.html'){
                    document.getElementById('1-1-php-dasar').classList.add('active');
                } else if(link.getAttribute('href') == currentPage){
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>