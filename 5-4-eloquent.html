<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Belajar Laravel</title>

    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="container">
        <aside id="aside">

        </aside>
        <main>
            <header>
                
            </header>

            <div class="content">
<pre>
    ğŸ“˜ 4ï¸âƒ£ Apa Itu Eloquent?

    Eloquent adalah:

    ORM (Object Relational Mapping) bawaan Laravel untuk berinteraksi dengan database menggunakan object PHP.

    Artinyaâ€¦

    Kita tidak lagi berpikir dalam bentuk:

    SELECT * FROM products;


    Tapi dalam bentuk:

    Product::all();


    Lebih clean. Lebih readable. Lebih modern.

    
    
    
    
    
    ğŸ§  Apa Itu ORM?

    ORM = Object Relational Mapping

    Konsepnya:

    Database	PHP
    Tabel	Class (Model)
    Baris	Object
    Kolom	Property
    Relasi	Method

    Jadi Eloquent mengubah:
    Database â†’ Object Oriented

    
    
    
    
    
    ğŸ”¥ Kenapa Laravel Pakai Eloquent?

    Karena Eloquent:

    âœ… Mudah dibaca
    âœ… Aman (hindari SQL Injection)
    âœ… Support relasi otomatis
    âœ… Support query chaining
    âœ… Terintegrasi dengan Model
    âœ… Support event, casting, accessor, mutator

    Dan ini bikin Laravel terasa â€œcleanâ€.

    
    
    
    
    
    ğŸ§± Cara Kerja Eloquent Secara Internal

    Contoh:

    Product::where('price', '>', 100000)->get();


    Yang terjadi di belakang layar:

    Eloquent membaca model Product

    Menentukan tabel: products

    Membuat SQL query otomatis

    Kirim query ke MySQL

    Ambil hasil

    Ubah hasil jadi collection object

    Kita tidak pernah melihat SQL-nya.

    
    
    
    
    
    ğŸ§  Eloquent Itu Sebenarnya Ada Berapa Banyak?

    Pertanyaan bagus ğŸ”¥

    Jawabannya:

    Eloquent bukan â€œjumlah fitur tetapâ€.

    Tapi terdiri dari beberapa bagian besar:

    
    
    
    
    
    1ï¸âƒ£ Query Builder Method

    Ratusan method tersedia, seperti:

    all()

    find()

    where()

    first()

    get()

    create()

    update()

    delete()

    orderBy()

    paginate()

    count()

    sum()

    avg()

    dll

    Total method aktif: 100+ method bawaan

    Dan bisa ditambah sendiri (custom scope).

    
    
    
    
    
    2ï¸âƒ£ Relationship Type

    Eloquent punya beberapa jenis relasi utama:

    One to One

    One to Many

    Many to Many

    Has Many Through

    Polymorphic (MorphOne, MorphMany, dll)

    Kalau dihitung lengkap, ada sekitar 8â€“10 tipe relasi berbeda.

   
   
   
   
   
    3ï¸âƒ£ Feature Tambahan Eloquent

    Selain query & relasi, Eloquent juga punya:

    Accessor & Mutator

    Casting

    Soft Delete

    Model Event

    Scope (Local & Global)

    Attribute

    Mass Assignment

    Lazy / Eager Loading

    Chunking

    Observer

    Jadi total konsep pentingnya bisa 20+ fitur besar.

    
    
    
    
    
    ğŸ§  Mental Model Eloquent

    Bayangkan seperti ini:

    Database itu dunia nyata.
    Model itu manusia.
    Eloquent itu sistem komunikasi antara manusia dan dunia nyata.

    Kita berbicara dengan Model,
    Model berbicara dengan Database.

    
    
    
    
    
    ğŸ¯ Perbandingan SQL vs Eloquent

    SQL:

    SELECT * FROM products WHERE price > 100000;


    Eloquent:

    Product::where('price', '>', 100000)->get();


    Lebih natural untuk programmer PHP.

    
    
    
    
    
    âš¡ Kapan Tidak Pakai Eloquent?

    Kadang kita pakai:

    Query Builder langsung

    Raw SQL

    Biasanya kalau:

    Query sangat kompleks

    Butuh performa super tinggi

    Query khusus database

    Tapi 90% aplikasi Laravel pakai Eloquent.

    
    
    
    
    
    ğŸ Kesimpulan Besar

    Eloquent adalah:

    Mesin utama Laravel untuk mengelola database secara object-oriented.

    Total fitur:

    100+ query method

    8â€“10 tipe relasi

    20+ fitur tambahan

    Tapi tenangâ€¦

    Kita tidak perlu hafal semua.

    
    
    
    
    
    Cukup kuasai:

    Basic Query

    Relasi

    Eager loading

    Mass assignment

    Itu sudah cukup untuk 80% project ğŸ”¥
</pre>




<br> <br>

<hr>

<br> <br>



<pre>
    ğŸ‘‰ find(), where(), first()

    Ini 3 method yang akan kamu pakai hampir setiap hari.

    
    
    
    
    
    ğŸ§  1ï¸âƒ£ find()
    ğŸ“Œ Fungsi:

    Mengambil data berdasarkan primary key (biasanya id).

    Contoh:
    Product::find(1);


    Artinya:

    Ambil data dari tabel products dengan id = 1

    SQL-nya kira-kira:

    SELECT * FROM products WHERE id = 1 LIMIT 1;

    âš  Kalau Data Tidak Ada?

    find() akan mengembalikan:

    null


    Jadi harus hati-hati:

    $product = Product::find(1);

    if ($product) {
        echo $product->name;
    }

    ğŸ”¥ Versi Lebih Aman: findOrFail()
    Product::findOrFail(1);


    Kalau tidak ada data:
    â¡ otomatis 404 error

    Ini sering dipakai di controller.

    
    
    
    
    
    ğŸ§  2ï¸âƒ£ where()
    ğŸ“Œ Fungsi:

    Mencari data dengan kondisi tertentu.

    Contoh Dasar:
    Product::where('price', '>', 100000)->get();


    Artinya:

    Ambil semua produk dengan harga > 100000

    
    
    
    
    
    âš  Penting!

    where() BELUM mengeksekusi query.

    Ia hanya membangun query.

    Query baru jalan saat kita pakai:

    get()

    first()

    count()

    dll

    Contoh Salah (Pemula sering salah):
    Product::where('price', '>', 100000);


    Ini tidak ambil data.

    Harus:

    Product::where('price', '>', 100000)->get();

    
    
    
    
    
    ğŸ§  Multiple Where
    Product::where('price', '>', 100000)
        ->where('is_active', 1)
        ->get();

    ğŸ”¥ Versi Singkat

    Kalau operator "=" bisa:

    Product::where('name', 'Laptop')->get();

    
    
    
    
    
    ğŸ§  3ï¸âƒ£ first()
    ğŸ“Œ Fungsi:

    Mengambil 1 data pertama dari hasil query.

    Contoh:
    Product::where('price', '>', 100000)->first();


    Artinya:

    Ambil 1 produk pertama dengan harga > 100000

    SQL kira-kira:

    SELECT * FROM products WHERE price > 100000 LIMIT 1;

    
    
    
    
    
    âš  Perbedaan get() vs first()
    get()

    Mengembalikan:

    Collection

    first()

    Mengembalikan:

    Object Model atau null

    Contoh Perbedaan:
    $products = Product::where('price', '>', 100000)->get();


    Loop:

    foreach ($products as $product)

    $product = Product::where('price', '>', 100000)->first();


    Langsung akses:

    $product->name;

    
    
    
    
    
    ğŸ”¥ Versi Aman: firstOrFail()
    Product::where('price', '>', 100000)->firstOrFail();


    Kalau tidak ada data:
    â¡ 404 otomatis

    
    
    
    
    
    ğŸ§  Ringkasan Perbedaan
    Method	Ambil Apa	Return
    find()	by ID	1 object / null
    where()	kondisi	perlu get()/first()
    first()	1 data pertama	object / null
    get()	semua data	collection
    
    
    
    
    
    ğŸ¯ Contoh Real di Controller
    public function show($id)
    {
        $product = Product::findOrFail($id);
        return view('products.show', compact('product'));
    }


    Atau:

    public function expensive()
    {
        $products = Product::where('price', '>', 1000000)->get();
        return view('products.expensive', compact('products'));
    }

    
    
    
    
    
    ğŸ§  Kapan Pakai Apa?

    âœ” Pakai find() kalau cari by ID
    âœ” Pakai where() kalau ada kondisi
    âœ” Pakai first() kalau cuma butuh 1 data
    âœ” Pakai get() kalau butuh banyak data

    
    
    
    
    
    ğŸ Kesimpulan

    3 method ini adalah fondasi Eloquent.

    Kalau kamu sudah paham ini,
    kamu sudah menguasai 60% query Laravel ğŸ”¥







    ADDITIONAL 1:
    QUESTION: apakah where itu berpotensi untuk tidak menggunakan INDEX database?



    Pertanyaan yang sangat cerdas! Jawabannya adalah Ya, sangat berpotensi.

    Meskipun kamu sudah memasang INDEX pada sebuah kolom, database (seperti MySQL) bisa saja memutuskan untuk mengabaikannya dan melakukan Full Table Scan (membaca seluruh isi tabel dari awal sampai akhir). Ini adalah salah satu penyebab utama aplikasi menjadi lambat saat data sudah mencapai ribuan atau jutaan baris.

    Berikut adalah beberapa kondisi yang menyebabkan `WHERE` mengabaikan INDEX:

    ---

    ### 1. Menggunakan Fungsi atau Manipulasi pada Kolom

    Jika kamu membungkus kolom di dalam fungsi, database tidak bisa menggunakan index karena nilai di dalam index tersebut sudah "berubah" di mata database.

    * Salah (Index diabaikan):
    ```sql
    SELECT * FROM products WHERE YEAR(created_at) = 2024;

    ```


    * Benar (Index digunakan):
    ```sql
    SELECT * FROM products WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31';

    ```



    ---

    ### 2. Menggunakan Wildcard (`%`) di Awal Kata

    Index pada database bekerja seperti indeks di buku telepon. Kamu bisa mencari "Budi%" dengan cepat karena urutannya jelas. Tapi kalau kamu mencari "%Budi", database harus mengecek setiap baris.

    * Index digunakan: `WHERE name LIKE 'Budi%'`
    * Index DIABAIKAN: `WHERE name LIKE '%Budi'`

    ---

    ### 3. Tipe Data Tidak Cocok (Implicit Conversion)

    Ini sering terjadi tanpa disadari. Jika kolom `merchant_id` bertipe String (Varchar), tapi kamu mencarinya menggunakan angka Integer, MySQL akan melakukan konversi tipe data pada setiap baris, yang mengakibatkan index tidak terpakai.

    * Potensi Lambat: `WHERE merchant_id = 123` (jika kolomnya string)
    * Cepat: `WHERE merchant_id = '123'`

    ---

    ### 4. Penggunaan Operator NOT atau Tidak Sama Dengan

    Operator negatif seperti `!=`, `<>`, atau `NOT IN` sering kali membuat database menyerah menggunakan index dan memilih melakukan *Full Table Scan* karena mencari "apa yang tidak ada" jauh lebih sulit daripada mencari "apa yang ada".

    ---

    ### 5. Kolom yang Kurang Selektif (Low Cardinality)

    Database punya "kecerdasan" bernama *Query Optimizer*. Jika kamu melakukan index pada kolom yang isinya hanya dua kemungkinan (misal: kolom `status` yang isinya hanya `aktif` dan `tidak_aktif`), database mungkin merasa:

    > *"Daripada repot-repot buka buku index tapi isinya hampir separuh tabel, mending saya baca langsung saja seluruh tabelnya."*

    ---

    ### 6. Melewatkan Urutan pada Composite Index

    Jika kamu membuat index gabungan (Composite Index) pada kolom `(merchant_id, category_id)`, kamu wajib menyertakan `merchant_id` di dalam `WHERE` agar index tersebut bekerja.

    * `WHERE merchant_id = 1 AND category_id = 2` (Index digunakan âœ…)
    * `WHERE category_id = 2` (Index diabaikan âŒ)

    ---

    ### Cara Cek Apakah Index Kamu Dipakai atau Tidak

    Kamu bisa menggunakan perintah EXPLAIN di tab SQL phpMyAdmin atau di terminal:

    ```sql
    EXPLAIN SELECT * FROM products WHERE price > 100000;

    ```

    Lihat kolom `type` dan `key`:

    * Jika `type` berisi `ALL`, berarti index tidak dipakai (Full Table Scan).
    * Jika `key` berisi nama index kamu, berarti index aman digunakan.

    Saran Saya:
    Saat kamu menulis query `WHERE`, bayangkan kamu sedang mencari nama di buku telepon. Jika caramu mencari memaksa kamu membuka setiap lembar buku, berarti query-mu tidak efektif.

    Apakah kamu sedang mengalami query yang terasa lambat saat ini?







    ADDITIONAL 2:
    QUESTION: apakah kode seperti berikut yang diambil adalah irisan dari kedua where?

    Product::where('price', '>', 100000)
    
            ->where('is_active', 1)
    
            ->get();


            

    Betul sekali! Dalam Laravel Eloquent, ketika kamu menyambungkan beberapa method `where()` secara berurutan (disebut *Method Chaining*), secara default Laravel akan menggabungkannya menggunakan operator logika AND.

    Dalam konsep himpunan, ini memang disebut sebagai Irisan (Intersection).

    ### 1. Bagaimana Database Membacanya?

    Kode Eloquent kamu akan diterjemahkan menjadi perintah SQL seperti ini:

    ```sql
    SELECT * FROM products 
    WHERE price > 100000 
    AND is_active = 1;

    ```

    Data yang ditarik hanya data yang memenuhi kedua syarat tersebut sekaligus. Jika ada produk yang harganya mahal tapi tidak aktif, atau produk aktif tapi harganya murah, mereka tidak akan ikut terbawa.

    ---

    ### 2. Visualisasi Irisan

    Bayangkan kamu memiliki dua lingkaran kriteria:

    * Lingkaran A: Semua produk dengan harga > 100.000.
    * Lingkaran B: Semua produk yang statusnya aktif (`is_active = 1`).

    Hasil dari query kamu adalah area di tengah-tengah di mana kedua lingkaran tersebut bertumpang tindih.

    ---

    ### 3. Bagaimana jika ingin "Gabungan" (Bukan Irisan)?

    Jika maksudmu adalah ingin mengambil produk yang harganya mahal ATAU produk yang aktif (salah satu syarat terpenuhi sudah cukup), maka kamu harus menggunakan `orWhere()`.

    ```php
    // Ini adalah GABUNGAN (Union)
    Product::where('price', '>', 100000)
            ->orWhere('is_active', 1)
            ->get();

    ```

    Dalam SQL, ini menjadi: `WHERE price > 100000 OR is_active = 1`.

    ---

    ### 4. Tips Performa: Masalah Index Lagi

    Menyambung pertanyaanmu sebelumnya tentang INDEX, jika kamu sering menjalankan query "irisan" seperti ini:

    * Jika kamu hanya punya index di `price`, database akan mencari harga dulu, baru memfilter `is_active` secara manual.
    * Jika datanya sangat besar (jutaan), akan jauh lebih cepat jika kamu membuat Composite Index (Index Gabungan) untuk kedua kolom tersebut sekaligus.

    Di Migration:

    ```php
    $table->index(['price', 'is_active']);

    ```

    ---

    ### ğŸ’¡ Hal yang Perlu Diwaspadai: Prioritas Query

    Hati-hati jika kamu mencampur `where` dan `orWhere`. Hasilnya bisa membingungkan karena urutan eksekusi.

    Contoh Masalah:
    `where A -> where B -> orWhere C`
    Database akan membacanya sebagai: `(A AND B) OR C`.

    Jika kamu ingin `A AND (B OR C)`, kamu harus menggunakan Parameter Grouping (Closure):

    ```php
    Product::where('price', '>', 100000)
        ->where(function ($query) {
            $query->where('is_active', 1)
                ->orWhere('is_featured', 1);
        })->get();

    ```

    Apakah query "irisan" ini rencananya akan kamu gunakan untuk fitur filter di halaman katalog produkmu?
</pre>


            </div>
        </main>
    </div>
    <script>
        fetch('layout/aside.html').then( response => response.text()).then( data => {
            document.getElementById('aside').innerHTML = data;

            const currentPage = window.location.pathname.split('/').pop() || 'index.html';
            const links = document.querySelectorAll('aside a');

            links.forEach(link => {
                if(currentPage == 'index.html'){
                    document.getElementById('1-1-php-dasar').classList.add('active');
                } else if(link.getAttribute('href') == currentPage){
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>